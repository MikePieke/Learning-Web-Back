In the beginning, there was data. And data was in abundance, scattered across devices and systems, locked away in proprietary formats. It wasn’t until the advent of modern networking that data began to flow, connecting once-isolated systems in a web of connectivity and information exchange.

As we delve into the realm of streams in Node.js, we embrace the philosophy of handling data in motion. Streams provide a method for managing data that arrives incrementally, allowing for the processing of this data as it’s received rather than waiting for the entire dataset to load. This efficiency in data handling is particularly advantageous when dealing with large files, real-time data, or network-based data sources.

## Understanding Streams

Streams in Node.js are built on four primary types:
1. **Readable Streams**: Used to read data.
2. **Writable Streams**: Used to write data.
3. **Duplex Streams**: Used for both reading and writing.
4. **Transform Streams**: Applied when data needs to be modified or transformed during the read/write process.

Each type of stream operates on a foundation of event handling, relying on core events such as `data`, `end`, `error`, and `finish`. By attaching event listeners to these streams, you can control the data flow, respond to errors, and finalize processing as data transmission completes.

## Practical Example with a Readable Stream

Imagine a scenario where you need to process a file containing several gigabytes of data. Loading the entire file into memory would be inefficient and, in many cases, impractical. Instead, you can use a readable stream to process chunks of the file in manageable segments.

Here’s a simplified example of a readable stream in Node.js:

```javascript
const fs = require('fs');

const readableStream = fs.createReadStream('sample.txt', {
  encoding: 'utf8',
  highWaterMark: 16 * 1024 // 16KB chunks
});

readableStream.on('data', (chunk) => {
  console.log('Received chunk:', chunk);
});

readableStream.on('end', () => {
  console.log('Stream ended');
});

readableStream.on('error', (err) => {
  console.error('Stream error:', err);
});